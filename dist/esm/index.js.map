{"version":3,"sources":["../../src/thread.ts","../../src/db.ts","../../src/index.ts"],"sourcesContent":["import type { Message, Job, iWorker, Db } from './index.d'\r\nimport * as os from 'os'\r\nimport { Worker } from 'worker_threads'\r\nimport { ensureDirSync } from 'fs-extra'\r\nimport { exec } from 'shelljs'\r\n\r\nconst queue: Job[] = []\r\nconst cpus = os.cpus()\r\nexport const workerCount = cpus.length\r\nconst createTableRegex = /CREATE TABLE IF NOT EXISTS ([^\\s]+) \\(/\r\n\r\nlet workers: iWorker[] = []\r\nlet nextId = 0\r\nlet cleaningUp = false\r\nlet processing = 0\r\n\r\n/**\r\n * Start workers\r\n */\r\n async function start (workerPath: string, startup: (worker: Worker, index: number) => void, cleanup: () => boolean) {\r\n    return new Promise(resolve => {\r\n    /**\r\n     * Spawns a worker\r\n     */\r\n    function spawn(cpuInfo: os.CpuInfo, index: number) {\r\n      const worker = new Worker(workerPath)\r\n\r\n      // Current item from the queue\r\n      let job: Job = null \r\n\r\n      /**\r\n       * If work exists, dequeue it and send it to the worker \r\n       */\r\n      function takeWork() {\r\n        if (!job && queue.length) {\r\n          // If there's a job in the queue, send it to the worker\r\n          processing += 1\r\n          job = queue.shift()\r\n\r\n          worker.postMessage(job.message)\r\n        }\r\n      }\r\n\r\n      worker\r\n        /**\r\n         * Worker is online, register its ability to take work from the master queue\r\n         */\r\n        .on('online', () => {\r\n          workers.push({\r\n            takeWork,\r\n            shutdown: () => worker.terminate()\r\n          })\r\n\r\n          // Start taking work\r\n          takeWork()\r\n        })\r\n\r\n        /**\r\n         * Worker has received a message, process it\r\n         */\r\n        .on('message', async (result: Db | true) => {\r\n          if (result === true) {\r\n            // Processing is complete\r\n            processing -= 1\r\n\r\n            if (queue.length === 0 && processing === 0) {\r\n              // All processing is complete\r\n              if (cleanup() === true) {\r\n                return resolve(true)\r\n              }\r\n            }\r\n          } else {\r\n            // New request\r\n            if (job === null) {\r\n              // No job exists, leave\r\n              return \r\n            }\r\n    \r\n            job.resolve(result as Db)          \r\n            job = null\r\n    \r\n            takeWork()\r\n          }\r\n        })\r\n\r\n        /**\r\n         * Worker has received an error\r\n         */\r\n        .on('error', (err) => {\r\n          console.error(err)\r\n        })\r\n      \r\n      // Startup this thread with the worker and its index\r\n      startup(worker, index)\r\n    }\r\n\r\n    // Spawn each worker\r\n    cpus.forEach(spawn)\r\n  })\r\n}\r\n\r\n/**\r\n * Queue up work for a worker\r\n * @param {object} message \r\n * @returns \r\n */\r\nexport const doWork = async (message: Message): Promise<Db> => {\r\n  return new Promise((resolve, reject) => {\r\n    queue.push({\r\n      resolve,\r\n      reject,\r\n      message\r\n    })\r\n    \r\n    let i = 0\r\n\r\n    for (const worker of workers) {\r\n      // Loop through all workers\r\n\r\n      if (i === nextId) {\r\n        // Round-robin workers to make sure distribution is fair\r\n        worker.takeWork()\r\n        nextId = (nextId + 1) % workerCount\r\n        break\r\n      }\r\n      i += 1\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Start SQLite Batch Writes\r\n */\r\nexport const startWriters = async (dbPath: string, fileName: string, createTableSql: string, transactionsFactory: (data: any[]) => string, consolidate: boolean = false) => {\r\n  ensureDirSync(dbPath)\r\n\r\n  return start(\r\n    __dirname + '/../dist/insert.js',\r\n\r\n    // Startup\r\n    (worker, index) => {\r\n      // Create the SQLite database per worker\r\n      worker.postMessage({\r\n        type: 'connect',\r\n        path: dbPath + '/' + fileName + '.' + index + '.sqlite',\r\n        transactions: transactionsFactory.toString() || 'function (sql) { return sql }'\r\n      })\r\n\r\n      // Register the database to insert into\r\n      worker.postMessage({\r\n        sql: createTableSql\r\n      })\r\n    },\r\n\r\n    // Cleanup after all workers are finished\r\n    () => {\r\n      if (queue.length > 0 || consolidate === false || cleaningUp) {\r\n        // No clean up coming on\r\n        return false\r\n      }\r\n\r\n      cleaningUp = true\r\n\r\n      workers.forEach(w => w.shutdown())\r\n\r\n      const consolidatedFilePath = dbPath + '/' + fileName + '.sqlite'\r\n\r\n      const commands: string[] = [\r\n        `(rm -f \"${consolidatedFilePath}\" && touch \"${consolidatedFilePath}\")`\r\n      ]\r\n\r\n      for (let i = 0; i  < workerCount; i++) {\r\n        const filePath = dbPath + '/' + fileName + '.' + i + '.sqlite'\r\n        const tableName = createTableSql.match(createTableRegex)[1]\r\n\r\n        commands.push(`(sqlite3 \"${filePath}\" \".dump ${tableName}\" | sed -e 's/CREATE TABLE ${tableName} /CREATE TABLE IF NOT EXISTS ${tableName} /' | sqlite3 \"${consolidatedFilePath}\")`)\r\n        commands.push(`(rm -f \"${filePath}\" && rm -f \"${filePath}-journal\")`)\r\n      }\r\n\r\n      exec(`((${commands.join(' && ')}) & wait)`)\r\n\r\n      return true\r\n    }\r\n  )\r\n}\r\n","import SqliteDatabaseConnection from 'better-sqlite3'\r\nimport { doWork } from './thread'\r\nimport { ensureFileSync } from  'fs-extra'\r\n\r\n/**\r\n * A cache of all connections\r\n */\r\nconst cache: {\r\n  [key: string]: SqliteDatabaseConnection\r\n} = {}\r\n\r\n/**\r\n * Get a sqlite database connection\r\n */\r\nexport const getDb = (path: string) => {\r\n  if (cache[path] === undefined) {\r\n    ensureFileSync(path)\r\n    cache[path] = new SqliteDatabaseConnection(path, { verbose: console.log })\r\n  }\r\n\r\n  return cache[path]\r\n}\r\n\r\n/**\r\n * enqueue\r\n */\r\n export const enqueue = async (data: any[]) => {\r\n  return doWork({ type: 'collection', data })\r\n}\r\n\r\n/**\r\n * run\r\n */\r\nexport const run = (query: string, parameters: Object | undefined = undefined, db: SqliteDatabaseConnection): Object[] => {\r\n  const statement = db.prepare(query)\r\n  if (parameters === undefined) {\r\n    return statement.run()\r\n  } else {\r\n    return statement.bind(parameters).run()\r\n  }\r\n}\r\n\r\n/**\r\n * query\r\n * @param query sql\r\n * @param parameters Object\r\n * @param db SqliteDatabaseConnection\r\n * @return Object[]\r\n */\r\nexport const query = (query: string, parameters: Object = {}, db: SqliteDatabaseConnection): Object[] => {\r\n  const statement = db.prepare(query)\r\n  return statement.bind(parameters).all()\r\n}\r\n","import { workerCount as WorkerCount, startWriters as StartWriters } from './thread'\r\nimport { enqueue as Enqueue, getDb as GetDb } from './db'\r\n\r\nexport const startWriters = StartWriters\r\nexport const enqueue = Enqueue\r\nexport const getDb = GetDb\r\nexport const workerCount = WorkerCount\r\n"],"mappings":"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","names":["os","Worker","ensureDirSync","exec","queue","cpus","workerCount","createTableRegex","workers","nextId","cleaningUp","processing","start","workerPath","startup","cleanup","resolve","spawn","cpuInfo","index","worker","job","takeWork","result","err","doWork","message","reject","i","startWriters","dbPath","fileName","createTableSql","transactionsFactory","consolidate","w","consolidatedFilePath","commands","filePath","tableName","SqliteDatabaseConnection","ensureFileSync","cache","getDb","path","SqliteDatabaseConnection","enqueue","data","doWork","startWriters","enqueue","getDb","workerCount"]}