{"version":3,"sources":["../../src/insert.ts","../../src/thread.ts","../../src/db.ts","../../src/index.ts"],"sourcesContent":["import { parentPort } from 'worker_threads'\r\nimport { getDb } from '.'\r\n\r\nlet db\r\nlet transactionFactory\r\n\r\nparentPort.on('message', (command) => {\r\n  const { type } = command\r\n\r\n  if (type === 'connect') {\r\n    // Initial connection\r\n    const { transactions, path } = command\r\n\r\n    db = getDb(path)\r\n    db.exec('PRAGMA journal_mode = OFF;')\r\n    db.exec('PRAGMA synchronous = 0;')\r\n    db.exec('PRAGMA cache_size = 1000000;')\r\n    db.exec('PRAGMA locking_mode = EXCLUSIVE')\r\n    db.exec('PRAGMA temp_store = MEMORY;')\r\n\r\n    transactionFactory = new Function(`return ${transactions}`)()\r\n\r\n  } else if (type === 'collection') {\r\n    // Dealing with transactions\r\n    const { data } = command\r\n    db.exec(`BEGIN TRANSACTION;${transactionFactory(data)}COMMIT;`)\r\n    parentPort.postMessage(true)\r\n\r\n  } else {\r\n    // Arbitrary sql\r\n    const { sql } = command\r\n    parentPort.postMessage(db.exec(sql))\r\n  }\r\n})\r\n","import type { Message, Job, iWorker, Db } from './index.d'\r\nimport * as os from 'os'\r\nimport { Worker } from 'worker_threads'\r\nimport { ensureDirSync } from 'fs-extra'\r\nimport { exec } from 'shelljs'\r\n\r\nconst queue: Job[] = []\r\nconst cpus = os.cpus()\r\nexport const workerCount = cpus.length\r\nconst createTableRegex = /CREATE TABLE IF NOT EXISTS ([^\\s]+) \\(/\r\n\r\nlet workers: iWorker[] = []\r\nlet nextId = 0\r\nlet cleaningUp = false\r\nlet processing = 0\r\n\r\n/**\r\n * Start workers\r\n */\r\n async function start (workerPath: string, startup: (worker: Worker, index: number) => void, cleanup: () => boolean) {\r\n    return new Promise(resolve => {\r\n    /**\r\n     * Spawns a worker\r\n     */\r\n    function spawn(cpuInfo: os.CpuInfo, index: number) {\r\n      const worker = new Worker(workerPath)\r\n\r\n      // Current item from the queue\r\n      let job: Job = null \r\n\r\n      /**\r\n       * If work exists, dequeue it and send it to the worker \r\n       */\r\n      function takeWork() {\r\n        if (!job && queue.length) {\r\n          // If there's a job in the queue, send it to the worker\r\n          processing += 1\r\n          job = queue.shift()\r\n\r\n          worker.postMessage(job.message)\r\n        }\r\n      }\r\n\r\n      worker\r\n        /**\r\n         * Worker is online, register its ability to take work from the master queue\r\n         */\r\n        .on('online', () => {\r\n          workers.push({\r\n            takeWork,\r\n            shutdown: () => worker.terminate()\r\n          })\r\n\r\n          // Start taking work\r\n          takeWork()\r\n        })\r\n\r\n        /**\r\n         * Worker has received a message, process it\r\n         */\r\n        .on('message', async (result: Db | true) => {\r\n          if (result === true) {\r\n            // Processing is complete\r\n            processing -= 1\r\n\r\n            if (queue.length === 0 && processing === 0) {\r\n              // All processing is complete\r\n              if (cleanup() === true) {\r\n                return resolve(true)\r\n              }\r\n            }\r\n          } else {\r\n            // New request\r\n            if (job === null) {\r\n              // No job exists, leave\r\n              return \r\n            }\r\n    \r\n            job.resolve(result as Db)          \r\n            job = null\r\n    \r\n            takeWork()\r\n          }\r\n        })\r\n\r\n        /**\r\n         * Worker has received an error\r\n         */\r\n        .on('error', (err) => {\r\n          console.error(err)\r\n        })\r\n      \r\n      // Startup this thread with the worker and its index\r\n      startup(worker, index)\r\n    }\r\n\r\n    // Spawn each worker\r\n    cpus.forEach(spawn)\r\n  })\r\n}\r\n\r\n/**\r\n * Queue up work for a worker\r\n * @param {object} message \r\n * @returns \r\n */\r\nexport const doWork = async (message: Message): Promise<Db> => {\r\n  return new Promise((resolve, reject) => {\r\n    queue.push({\r\n      resolve,\r\n      reject,\r\n      message\r\n    })\r\n    \r\n    let i = 0\r\n\r\n    for (const worker of workers) {\r\n      // Loop through all workers\r\n\r\n      if (i === nextId) {\r\n        // Round-robin workers to make sure distribution is fair\r\n        worker.takeWork()\r\n        nextId = (nextId + 1) % workerCount\r\n        break\r\n      }\r\n      i += 1\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * Start SQLite Batch Writes\r\n */\r\nexport const startWriters = async (dbPath: string, fileName: string, createTableSql: string, transactionsFactory: (data: any[]) => string, consolidate: boolean = false) => {\r\n  ensureDirSync(dbPath)\r\n\r\n  return start(\r\n    __dirname + '/../dist/insert.js',\r\n\r\n    // Startup\r\n    (worker, index) => {\r\n      // Create the SQLite database per worker\r\n      worker.postMessage({\r\n        type: 'connect',\r\n        path: dbPath + '/' + fileName + '.' + index + '.sqlite',\r\n        transactions: transactionsFactory.toString() || 'function (sql) { return sql }'\r\n      })\r\n\r\n      // Register the database to insert into\r\n      worker.postMessage({\r\n        sql: createTableSql\r\n      })\r\n    },\r\n\r\n    // Cleanup after all workers are finished\r\n    () => {\r\n      if (queue.length > 0 || consolidate === false || cleaningUp) {\r\n        // No clean up coming on\r\n        return false\r\n      }\r\n\r\n      cleaningUp = true\r\n\r\n      workers.forEach(w => w.shutdown())\r\n\r\n      const consolidatedFilePath = dbPath + '/' + fileName + '.sqlite'\r\n\r\n      const commands: string[] = [\r\n        `(rm -f \"${consolidatedFilePath}\" && touch \"${consolidatedFilePath}\")`\r\n      ]\r\n\r\n      for (let i = 0; i  < workerCount; i++) {\r\n        const filePath = dbPath + '/' + fileName + '.' + i + '.sqlite'\r\n        const tableName = createTableSql.match(createTableRegex)[1]\r\n\r\n        commands.push(`(sqlite3 \"${filePath}\" \".dump ${tableName}\" | sed -e 's/CREATE TABLE ${tableName} /CREATE TABLE IF NOT EXISTS ${tableName} /' | sqlite3 \"${consolidatedFilePath}\")`)\r\n        commands.push(`(rm -f \"${filePath}\" && rm -f \"${filePath}-journal\")`)\r\n      }\r\n\r\n      exec(`((${commands.join(' && ')}) & wait)`)\r\n\r\n      return true\r\n    }\r\n  )\r\n}\r\n","import SqliteDatabaseConnection from 'better-sqlite3'\r\nimport { doWork } from './thread'\r\nimport { ensureFileSync } from  'fs-extra'\r\n\r\n/**\r\n * A cache of all connections\r\n */\r\nconst cache: {\r\n  [key: string]: SqliteDatabaseConnection\r\n} = {}\r\n\r\n/**\r\n * Get a sqlite database connection\r\n */\r\nexport const getDb = (path: string) => {\r\n  if (cache[path] === undefined) {\r\n    ensureFileSync(path)\r\n    cache[path] = new SqliteDatabaseConnection(path)\r\n  }\r\n\r\n  return cache[path]\r\n}\r\n\r\n/**\r\n * enqueue\r\n */\r\n export const enqueue = async (data: any[]) => {\r\n  return doWork({ type: 'collection', data })\r\n}\r\n\r\n/**\r\n * run\r\n */\r\nexport const run = (query: string, parameters: Object | undefined = undefined, db: SqliteDatabaseConnection): Object[] => {\r\n  const statement = db.prepare(query)\r\n  if (parameters === undefined) {\r\n    return statement.run()\r\n  } else {\r\n    return statement.bind(parameters).run()\r\n  }\r\n}\r\n\r\n/**\r\n * query\r\n * @param query sql\r\n * @param parameters Object\r\n * @param db SqliteDatabaseConnection\r\n * @return Object[]\r\n */\r\nexport const query = (query: string, parameters: Object = {}, db: SqliteDatabaseConnection): Object[] => {\r\n  const statement = db.prepare(query)\r\n  return statement.bind(parameters).all()\r\n}\r\n","import { workerCount as WorkerCount, startWriters as StartWriters } from './thread'\r\nimport { enqueue as Enqueue, getDb as GetDb } from './db'\r\n\r\nexport const startWriters = StartWriters\r\nexport const enqueue = Enqueue\r\nexport const getDb = GetDb\r\nexport const workerCount = WorkerCount\r\n"],"mappings":"AAAA,OAAS,cAAAA,MAAkB,iBCC3B,UAAYC,MAAQ,KACpB,OAAS,UAAAC,MAAc,iBACvB,OAAS,iBAAAC,MAAqB,WAC9B,OAAS,QAAAC,MAAY,UAGrB,IAAMC,EAAU,OAAK,EACRC,EAAcD,EAAK,OCRhC,OAAOE,MAA8B,iBAErC,OAAS,kBAAAC,MAAuB,WAKhC,IAAMC,EAEF,CAAC,EAKQC,EAASC,IAChBF,EAAME,KAAU,SAClBH,EAAeG,CAAI,EACnBF,EAAME,GAAQ,IAAIC,EAAyBD,CAAI,GAG1CF,EAAME,ICfR,IAAME,EAAQA,EHFrB,IAAIC,EACAC,EAEJC,EAAW,GAAG,UAAYC,GAAY,CACpC,GAAM,CAAE,KAAAC,CAAK,EAAID,EAEjB,GAAIC,IAAS,UAAW,CAEtB,GAAM,CAAE,aAAAC,EAAc,KAAAC,CAAK,EAAIH,EAE/BH,EAAKO,EAAMD,CAAI,EACfN,EAAG,KAAK,4BAA4B,EACpCA,EAAG,KAAK,yBAAyB,EACjCA,EAAG,KAAK,8BAA8B,EACtCA,EAAG,KAAK,iCAAiC,EACzCA,EAAG,KAAK,6BAA6B,EAErCC,EAAqB,IAAI,SAAS,UAAUI,GAAc,EAAE,CAE9D,SAAWD,IAAS,aAAc,CAEhC,GAAM,CAAE,KAAAI,CAAK,EAAIL,EACjBH,EAAG,KAAK,qBAAqBC,EAAmBO,CAAI,UAAU,EAC9DN,EAAW,YAAY,EAAI,CAE7B,KAAO,CAEL,GAAM,CAAE,IAAAO,CAAI,EAAIN,EAChBD,EAAW,YAAYF,EAAG,KAAKS,CAAG,CAAC,CACrC,CACF,CAAC","names":["parentPort","os","Worker","ensureDirSync","exec","cpus","workerCount","SqliteDatabaseConnection","ensureFileSync","cache","getDb","path","SqliteDatabaseConnection","getDb","db","transactionFactory","parentPort","command","type","transactions","path","getDb","data","sql"]}